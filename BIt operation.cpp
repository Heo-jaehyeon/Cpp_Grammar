#include <iostream>
using namespace std;

// 비트 연산

// 언제 필요한가?
// 비트 단위의 조작이 필요할 때
// 대표적으로 비트플래그(Bitflag)

// - bitwise not
// 단일 숫자의 모든 비트를 대상으로, 0은 1, 1은 0으로 뒤바꿈

// & bitwise nand
// 두 숫자의 모든 비트 쌍을 대상으로, and를 한다

// | bitwise or
// 두 숫자의 모든 비트 쌍을 대상으로, or를 한다

// ^ bitwise xor
// 두 숫자의 모든 비트 쌍을 대상으로, xor를 한다
// xor 란? 두 숫자가 같으면 0, 다르면 1로 출력

// 비트시프트(bitshift)

// << 비트 좌측 이동
// 비트열을 N만큼 왼쪽으로 이동
// 왼쪽에 넘치는 N개의 비트는 버림, 새로 생성되는 N개의 비트는 0
//	*2를 할 때 자주 보이는 패턴

// >> 비트 우측 이동
// 비트열을 N만큼 오른쪽으로 이동
// 오른쪽의 넘치는 N개의 비트는 버림.
// 왼쪽 생성되는 N개의 비트는
// - 부호 비트가 존재할 경우 부호 비트를 따라감 (부호있는 정수라면 이 부분을 유의)
// - 아니면 0 (unsigned 타입이면 무조건)

// 실습
// 0b0000 [무적][변이][스턴][공중부양]

unsigned char flag; // 부호를 없애야 >> 를 하더라도 부호비트가 딸려오지 않음

int main()
{
	flag = (1 << 3);
	// 1이라는 숫자를 왼쪽으로 3칸 이동
	// flag = 8 와 같은 명령어 (숫자가 너무 커지면 오히려 불편)
	// 무적 상태로 만든다
	
	flag |= (1 << 2);
	// 변이 상태(무적 + 변이)
	// flag |= 4; 와 같은 명령어
	
	// 무적인지 확인하고 싶다면? (다른 상태는 관심 없음)
	// Bitmask
	bool invincible = ((flag & (1 << 3)) != 0);
	
	// 무적이거나 스턴 상태인지 확인하고 싶다면?
	bool stunOrInvincible = ((flag & 0b1010) != 0);
	// 이렇게 하거나 또는
	bool mask = (1<<3) | (1 << 1);
	bool stunOrInvincible = ((flag & mask) != 0);
	// 이런식으로도 가능 !
}
